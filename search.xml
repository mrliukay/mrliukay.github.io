<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网云穿设置内网穿透</title>
      <link href="/liukai/2023/10/02/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0/"/>
      <url>/liukai/2023/10/02/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一次使用网云穿实现内网穿透操作"><a href="#记录一次使用网云穿实现内网穿透操作" class="headerlink" title="记录一次使用网云穿实现内网穿透操作"></a>记录一次使用网云穿实现内网穿透操作</h1><hr><blockquote><p>摘要</p><p>这段时间也很少写博客了,一方面工作表较忙,一方面觉得有些东西在百度上都能找到,甚至比我自己记录的详细,有些笔记也就没打,</p><p>这次记录笔记主要是觉得这个 网云穿 很好用,分享给大家.</p></blockquote><hr><h2 id="1-什么是内网穿透"><a href="#1-什么是内网穿透" class="headerlink" title="1  什么是内网穿透?"></a>1  什么是内网穿透?</h2><blockquote><p>内网穿透也叫内网映射，将本地服务器内网IP端口提供到外网，实现外网连接访问的过程。内网穿透可以将原本只能在本机、本局域网内访问的项目网站等，实现外网也同样可以访问。</p></blockquote><h2 id="2-内网穿透有什么用途"><a href="#2-内网穿透有什么用途" class="headerlink" title="2  内网穿透有什么用途?"></a>2  内网穿透有什么用途?</h2><blockquote><p>最直接的作用就是可以对方可以使用外网直接访问你本地的或者局域网(当然一般需要公网IP);</p><p>举个我的例子,这段时间一直出差,我带的自己的笔记本电脑,但是项目需要和前端联调,我和前端又不在同一局域网下(不在同一网段),这个时候其实解决方式有很多,最常见的一般有两种:</p><ul><li>发测试,前端调用测试进行联调;</li><li>内网穿透,直接调我本地联调;</li></ul><p>第一种解决方式如果公司使用的容器化部署(docker等),并且测试服务器提供的有公网IP可以直接访问这种其实最舒服,IDEA中直接一个运行就发到测试了,也很方便;</p><p>第二种内网穿透就不必多说了,直接调用的我本地,随时随地断点调试;</p><p>我们测试没有公网IP所以我这面做了个内网穿透给前端他们……</p></blockquote><h2 id="3-为什么选择网云穿"><a href="#3-为什么选择网云穿" class="headerlink" title="3  为什么选择网云穿?"></a>3  为什么选择网云穿?</h2><blockquote><p>市面上其实有很多内网穿透工具,比如  花生壳 , OpenFrp,飞鸽等等很多(当然很多都有免费的隧道,和免费的带宽等,你也可以开VIP享受更好的服务)</p><p>我的需求其实很简单就是简单的进行一下远程调试,而且我没有公网IP,我希望这玩意我可以”白嫖”一段时间就行了:</p><ul><li>网云传正好目前注册就送免费的隧道和3M的带宽;</li><li>网云穿还送随机的公网IP给注册的新用户</li></ul></blockquote><h2 id="4-实现"><a href="#4-实现" class="headerlink" title="4 实现"></a>4 实现</h2><blockquote><p>官网: <a href="https://xiaomy.net/">https://xiaomy.net/</a></p></blockquote><h3 id="4-1-注册并获取隧道和公网IP"><a href="#4-1-注册并获取隧道和公网IP" class="headerlink" title="4.1 注册并获取隧道和公网IP"></a>4.1 注册并获取隧道和公网IP</h3><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230914221658.png"></p><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230914224143.png"></p><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230914221832.png"></p><h3 id="4-2-下载-CentOS-Stream-9"><a href="#4-2-下载-CentOS-Stream-9" class="headerlink" title="4.2  下载(CentOS Stream 9 )"></a>4.2  下载(CentOS Stream 9 )</h3><pre><code class="bash">wget -O /usr/local/wyc/ https://down.xiaomy.net/linux/wyc_linux_64</code></pre><h3 id="4-3-编写服务脚本"><a href="#4-3-编写服务脚本" class="headerlink" title="4.3 编写服务脚本"></a>4.3 编写服务脚本</h3><blockquote><p>注意:</p><p>token就是我们上面截图注册开通免费隧道后的令牌</p></blockquote><pre><code class="bash">vim /usr/lib/systemd/system/wyc.service</code></pre><h3 id="4-4-授权"><a href="#4-4-授权" class="headerlink" title="4.4 授权"></a>4.4 授权</h3><pre><code class="bash">chmod 777 wyc.service</code></pre><h3 id="4-5-启动"><a href="#4-5-启动" class="headerlink" title="4.5  启动"></a>4.5  启动</h3><pre><code class="bash">systemctl start wyc.service</code></pre><h3 id="4-6-查看启动状态"><a href="#4-6-查看启动状态" class="headerlink" title="4.6 查看启动状态"></a>4.6 查看启动状态</h3><pre><code class="bash">systemctl status wyc.service</code></pre><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230914223927.png"></p><h2 id="5-演示效果"><a href="#5-演示效果" class="headerlink" title="5 演示效果"></a>5 演示效果</h2><blockquote><p>我是使用网云穿映射到我的nginx的地址监听端口的,这样我就能配置多个项目的接口地址路由给前端调试:</p><p>我们直接取到网云穿给我们的随机公网IP访问我们的接口文档试一下就可以</p></blockquote><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230914225206.png"></p>]]></content>
      
      
      <categories>
          
          <category> 运维服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenFeign</title>
      <link href="/liukai/2023/05/25/OpenFeign/"/>
      <url>/liukai/2023/05/25/OpenFeign/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenFeign记录"><a href="#OpenFeign记录" class="headerlink" title="OpenFeign记录"></a>OpenFeign记录</h1><blockquote><p>摘要:</p><p>本篇博客主要接受啊OpenFeign的相关知识点</p></blockquote><h2 id="1-什么是Feign"><a href="#1-什么是Feign" class="headerlink" title="1 什么是Feign"></a>1 什么是Feign</h2><blockquote><p>在介绍Feign之前先介绍一下Feign</p><p><strong>Feign集成了Ribbon、RestTemplate实现了负载均衡的执行Http调用，只不过对原有的方式（Ribbon+RestTemplate）进行了封装</strong>，开发者不必手动使用RestTemplate调服务，而是定义一个接口，在这个接口中标注一个注解即可完成服务调用，这样更加符合面向接口编程的宗旨，简化了开发。</p><p>OpenFeign其实就是Feign的一种升级罢了。但是Feign后期停止了迭代，所以现在很多新企业和公司开始使用OpenFeign，虽然目前也有很多企业也在使用Feign。</p></blockquote><h2 id="2-OpenFeign"><a href="#2-OpenFeign" class="headerlink" title="2  OpenFeign"></a>2  OpenFeign</h2><blockquote><p>OpenFeign在原来的Feign的基础山增加了支持SpringMVC的注解, 比如@RequestMapping(“&#x2F;path”)注解, 此外配合@FeignClient注解可以可以通过动态代理的形式产生实现类,调用其他服务的接口.</p></blockquote><pre><code class="java">@FeignClient(contextId = &quot;remoteDeptService&quot;, value = ServiceNameConstants.UMPS_SERVICE)public interface RemoteDeptService &#123;    /**     * 查收子级id列表     * @return 返回子级id列表     */    @GetMapping(value = &quot;/dept/child-id/&#123;deptId&#125;&quot;, headers = SecurityConstants.HEADER_FROM_IN)    R&lt;List&lt;Long&gt;&gt; listChildDeptId(@PathVariable(&quot;deptId&quot;) Long deptId);&#125;</code></pre><h3 id="2-1-OpenFeign和Feign的区别"><a href="#2-1-OpenFeign和Feign的区别" class="headerlink" title="2.1  OpenFeign和Feign的区别"></a>2.1  OpenFeign和Feign的区别</h3><blockquote><p>上面介绍其实已经知道区别所在了</p></blockquote><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230528175933.png"></p><h3 id="2-2-OpenFeign如何传参"><a href="#2-2-OpenFeign如何传参" class="headerlink" title="2.2 OpenFeign如何传参"></a>2.2 OpenFeign如何传参</h3><blockquote><p>传递json形式参数:</p><p><strong>使用@RequestBody注解进行json形式传参</strong></p></blockquote><pre><code class="java">@FeignClient(contextId = &quot;remoteDeptService&quot;, value = ServiceNameConstants.UMPS_SERVICE)public interface RemoteDeptService &#123;    @PostMapping(&quot;/openfeign/provider/order2&quot;)   Order createOrder2(@RequestBody Order order);&#125;</code></pre><blockquote><p>传递POJO表单形式参数:</p><p><strong>OpenFeign提供了@SpringQueryMap注解来传递表单形式参数</strong></p></blockquote><pre><code class="java">@FeignClient(contextId = &quot;remoteDeptService&quot;, value = ServiceNameConstants.UMPS_SERVICE)public interface RemoteDeptService &#123;    @GetMapping(&quot;/openfeign/provider/order1&quot;)   Order createOrder1(@SpringQueryMap Order order);&#125;</code></pre><blockquote><p>URL中传参:</p><p><strong>我们可以使用@PathVariable注解来完成URL中参数的传递</strong></p></blockquote><pre><code class="java">@FeignClient(contextId = &quot;remoteDeptService&quot;, value = ServiceNameConstants.UMPS_SERVICE)public interface RemoteDeptService &#123;    @GetMapping(&quot;/openfeign/provider/&#123;id&#125;&quot;)x   Order createOrder1(@PathVariable(&quot;id&quot;) Long id);&#125;</code></pre><blockquote><p>普通表达传参</p><p><strong>使用@RequestParam注解解决</strong></p></blockquote><pre><code class="java">@FeignClient(contextId = &quot;remoteDeptService&quot;, value = ServiceNameConstants.UMPS_SERVICE)public interface RemoteDeptService &#123;    @GetMapping(&quot;/openfeign/provider&quot;)x   Order createOrder1(@RequestParam(&quot;id&quot;) Long id,@RequestParam(&quot;name&quot;) String name);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openfeign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPEL表达式</title>
      <link href="/liukai/2023/05/20/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/liukai/2023/05/20/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="SPEL表达式"><a href="#SPEL表达式" class="headerlink" title="SPEL表达式"></a>SPEL表达式</h1><blockquote><p>照耀本篇文章主要介绍SPEL表达式的一些简单用法</p></blockquote><h2 id="1-SPEL表达式介绍"><a href="#1-SPEL表达式介绍" class="headerlink" title="1 SPEL表达式介绍"></a>1 SPEL表达式介绍</h2><blockquote><p>其实SPEL表达式和我们平时用的EL表达式很相似,我们用的最多的注解@Value注解就得到了体现;</p><p>但是EL表达式想要动态注入一些属性就显得比较无力了,这时候SPEL表达式就更先方便一些.</p></blockquote><h2 id="2-路径跳转"><a href="#2-路径跳转" class="headerlink" title="2 路径跳转"></a>2 路径跳转</h2><blockquote><p>由于SPEL表达式其实在实际项目当中使用的并不是太多,多以这里就不再进行这么多记录了,这里直接贴上另一位技术博主的一篇博文即可:</p><p><a href="https://juejin.cn/post/6987993458807930893">SpringBoot技术实践-SpEL&amp;EL表达式</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPEL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pig开源项目-Gateway超时配置</title>
      <link href="/liukai/2023/05/14/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-Gateway%E8%B6%85%E6%97%B6%E9%85%8D%E7%BD%AE/"/>
      <url>/liukai/2023/05/14/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-Gateway%E8%B6%85%E6%97%B6%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="网关超时配置"><a href="#网关超时配置" class="headerlink" title="网关超时配置"></a>网关超时配置</h1><blockquote><p>摘要:</p><p>本篇文章主要介绍Gateway网关超时配置</p></blockquote><h2 id="1-超时配置概念"><a href="#1-超时配置概念" class="headerlink" title="1 超时配置概念"></a>1 超时配置概念</h2><blockquote><p>路由超时配置可以为所有路由配置Http超时（响应和连接），并为每个特定路由覆盖Http超时。</p><p>简单来说就是</p><p>我们可以给网关配置<strong>全局超时</strong> 和 <strong>特定路由超时</strong></p><p>并且如果前者配置了后者也配置,那么后者会覆盖前者的超时配置;</p></blockquote><h2 id="2-具体配置"><a href="#2-具体配置" class="headerlink" title="2 具体配置"></a>2 具体配置</h2><blockquote><p>下面是代码实现超时配置的方案</p></blockquote><h3 id="2-1-全局超时配置"><a href="#2-1-全局超时配置" class="headerlink" title="2.1 全局超时配置"></a>2.1 全局超时配置</h3><pre><code class="yaml">spring:  cloud:    gateway:      httpclient:        connect-timeout: 1000        response-timeout: 10s</code></pre><blockquote><ul><li><strong>connect-timeout 必须以毫秒为单位指定连接超时时间.</strong></li><li><strong>response-timeout 必须指定为java.time.Duration</strong></li></ul></blockquote><h3 id="2-2-特定路由超时配置"><a href="#2-2-特定路由超时配置" class="headerlink" title="2.2 特定路由超时配置"></a>2.2 特定路由超时配置</h3><pre><code class="yaml">- id: pig-upms      # 唯一的服务ID  uri: lb://pig-upms # 注册中心的服务名称，实现负载均衡  predicates:  - Path=/admin/demo  #所有业务的请求前缀  metadata:    response-timeout: 200    connect-timeout: 200</code></pre><blockquote><p>可以通过路由的metadata以下两个参数配置每个路由超时：</p><ul><li><strong>connect-timeout 必须以毫秒为单位指定连接超时时间.</strong></li><li><strong>response-timeout 必须以毫秒为单位指定响应超时时间.</strong></li></ul></blockquote><h2 id="3-友链"><a href="#3-友链" class="headerlink" title="3 友链"></a>3 友链</h2><blockquote><p><a href="https://blog.csdn.net/abu935009066/article/details/112264485">网关 Spring Cloud Gateway HTTP超时配置</a></p><p><a href="https://www.yuque.com/pig4cloud/pig/gpltt6">网关超时</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gateway超时配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pig开源项目-网关限流</title>
      <link href="/liukai/2023/05/14/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81/"/>
      <url>/liukai/2023/05/14/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="网关限流"><a href="#网关限流" class="headerlink" title="网关限流"></a>网关限流</h1><blockquote><p>摘要:</p><p>本篇文章主要介绍Gateway实现限流的方式–<strong>令牌桶</strong></p></blockquote><h2 id="1-限流概念"><a href="#1-限流概念" class="headerlink" title="1 限流概念"></a>1 限流概念</h2><blockquote><p>限流是对某一时间窗口内的请求数进行限制,保持系统的可用性和稳定性,防止因为流量暴增而导致的系统运行缓慢或宕机.</p></blockquote><h2 id="2-常见的限流方案"><a href="#2-常见的限流方案" class="headerlink" title="2 常见的限流方案"></a>2 常见的限流方案</h2><blockquote><p>常见的限流算法有：<code>计数器</code>算法，<code>漏桶（Leaky Bucket）</code>算法，<code>令牌桶（Token Bucket）</code>算法。</p></blockquote><h2 id="3-Gateway限流方式"><a href="#3-Gateway限流方式" class="headerlink" title="3 Gateway限流方式"></a>3 Gateway限流方式</h2><blockquote><p><code>Spring Cloud Gateway</code>官方提供了<code>RequestRateLimiterGatewayFilterFactory</code>过滤器工厂，使用<code>Redis</code> 和<code>Lua</code>脚本实现了 <strong>令牌桶</strong> 的方式。</p></blockquote><h3 id="3-1-令牌桶限流介绍"><a href="#3-1-令牌桶限流介绍" class="headerlink" title="3.1 令牌桶限流介绍"></a>3.1 令牌桶限流介绍</h3><blockquote><p>令牌桶算法 是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。</p><p>放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌。所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。</p></blockquote><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230514225957.png"></p><h3 id="3-2-Gateway限流代码实现"><a href="#3-2-Gateway限流代码实现" class="headerlink" title="3.2 Gateway限流代码实现"></a>3.2 Gateway限流代码实现</h3><blockquote><p>Gateway官方提供了<strong>RequestRateLimiterGatewayFilterFactory</strong>过滤器工厂，使用redis和lua脚本实现了<strong>令牌桶</strong>的方式实现限流操作。</p></blockquote><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><pre><code class="yaml">spring:  redis:    host: localhost    port: 6379    password:  cloud:    gateway:      routes:        - id: cloud-gateway          uri: http://192.168.1.211:8088/          predicates:            - Path=/ytb/**          filters:            - StripPrefix=1            - name: RequestRateLimiter              args:                redis-rate-limiter.replenishRate: 1   # 令牌桶每秒填充速率                redis-rate-limiter.burstCapacity: 2   # 令牌桶总容量                key-resolver: &quot;#&#123;@pathKeyResolver&#125;&quot;   # 使用 SpEL 表达式按名称引用 bean</code></pre><blockquote><ul><li><code>replenishRate</code>，令牌桶每秒填充平均速率。</li><li><code>burstCapacity</code>，令牌桶总容量。</li><li><code>key-resolver</code>，用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据 #{@beanName} 从 Spring 容器中获取 Bean 对象。</li></ul></blockquote><h3 id="3-3-限流规则-key-resolver"><a href="#3-3-限流规则-key-resolver" class="headerlink" title="3.3 限流规则(key-resolver)"></a>3.3 限流规则(key-resolver)</h3><blockquote><p><code>URI</code>限流规则</p></blockquote><pre><code class="java">@Configurationpublic class KeyResolverConfiguration &#123;    @Bean    public KeyResolver pathKeyResolver()&#123;        return exchange -&gt; Mono.just(exchange.getRequest().getURI().getPath());    &#125;&#125;</code></pre><blockquote><p>参数限流 <strong>key-resolver: “#{@parameterKeyResolver}”</strong>(以下配置要求请求路径中必须携带 userId 参数)</p></blockquote><pre><code class="java">@Beanpublic KeyResolver parameterKeyResolver()&#123;    return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;userId&quot;));&#125;</code></pre><blockquote><p>IP限流 <strong>key-resolver: “#{@ipKeyResolver}”</strong></p></blockquote><pre><code class="java">@Beanpublic KeyResolver ipKeyResolver()&#123;    return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());&#125;</code></pre><h2 id="4-友链"><a href="#4-友链" class="headerlink" title="4 友链"></a>4 友链</h2><blockquote><p><a href="https://blog.csdn.net/zhang33565417/article/details/122117633">微服务系列：服务网关 Spring Cloud Gateway 限流配置</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis-reactive限流组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pig开源项目-网关</title>
      <link href="/liukai/2023/05/11/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E7%BD%91%E5%85%B3/"/>
      <url>/liukai/2023/05/11/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="网关学习"><a href="#网关学习" class="headerlink" title="网关学习"></a>网关学习</h1><blockquote><p>摘要:</p><p>本文主要介绍springcloud的gateway</p></blockquote><h2 id="1-Gateway简介"><a href="#1-Gateway简介" class="headerlink" title="1 Gateway简介"></a>1 Gateway简介</h2><blockquote><p>Spring Cloud Gateway是Spring官方基于<strong>Spring 5.0，Spring Boot 2.0和Project Reactor等技术</strong>开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的<strong>统一的API路由管理方式</strong>。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控&#x2F;埋点，和限流等。</p></blockquote><h2 id="2-为什么使用网关"><a href="#2-为什么使用网关" class="headerlink" title="2 为什么使用网关"></a>2 为什么使用网关</h2><blockquote><p>在微服务架构中，一个系统往往由多个微服务组成，而这些服务可能部署在不同机房、不同地区、不同域名下。这种情况下，客户端（例如浏览器、手机、软件工具等）想要直接请求这些服务，就需要知道它们具体的地址信息，例如 IP 地址、端口号等。</p><p>这种客户端直接请求服务的方式存在以下问题：</p><ol><li>当服务数量众多时，客户端需要维护大量的服务地址，这对于客户端来说，是非常繁琐复杂的;(硬编码维护确实不是办法)</li><li>在某些场景下可能会存在跨域请求的问题;</li><li>身份认证的难度大，每个微服务需要独立认证.</li></ol></blockquote><h2 id="3-网关有哪些基本功能"><a href="#3-网关有哪些基本功能" class="headerlink" title="3 网关有哪些基本功能"></a>3 网关有哪些基本功能</h2><blockquote><p>API 网关是一个搭建在客户端和微服务之间的服务，我们可以在 API 网关中处理一些非业务功能的逻辑，例如权限验证、监控、缓存、请求路由等。</p><p>认证、鉴权、熔断、限流、日志监控等等</p></blockquote><h2 id="4-为什么使用Gateway"><a href="#4-为什么使用Gateway" class="headerlink" title="4 为什么使用Gateway"></a>4 为什么使用Gateway</h2><blockquote><p>首先我们要知道Spring Cloud Gateway构建于Spring5.x版本,基于Springboot2.x,它是Spring的”亲儿子”,使用Gateway整合起来相对简单,</p><p>但是Zuul就不一样了,Zuul是Netflix公司的一款开源项目,虽然Spring Cloud也曾整合过Zuul作为网关,但是Zuul2.x经常出现”跳票”行为,Spring Cloud也就没有了整合的意思了,所以Zuul和Gateway严格来说并没有可比性,但是我们使用的话使用Gateway肯定没错.</p></blockquote><h2 id="5-Gateway几个常用术语"><a href="#5-Gateway几个常用术语" class="headerlink" title="5 Gateway几个常用术语"></a>5 Gateway几个常用术语</h2><h3 id="5-1-路由"><a href="#5-1-路由" class="headerlink" title="5.1 路由"></a>5.1 路由</h3><blockquote><p>routes: 路由, 它是由一个ID, 一个目标URL, 一组断言(Predicate), 一组过滤器(Filter)组成;</p></blockquote><h3 id="5-2-断言"><a href="#5-2-断言" class="headerlink" title="5.2 断言"></a>5.2 断言</h3><blockquote><p>predicates:  断言, 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。(值得注意的是,想要路由转发到指定的服务这一组断言则都要匹配上);</p><p>Gaeway内置断言如下:</p></blockquote><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/640.png"></p><h3 id="5-3-过滤器"><a href="#5-3-过滤器" class="headerlink" title="5.3 过滤器"></a>5.3 过滤器</h3><blockquote><p>所有生效的Filter都是Gateway的实例, 这个有点类似于我们Spring中Bean的生命周期中的前置后置处理器,同样Gateway的过滤器也是用于实现再请求前进行一些操作和在请求后进行一些操作.</p><p>Gateway的过滤器分为按照作用范围可以分为两种:一种是<strong>全局过滤器</strong>(GlobalFilter)一种是<strong>局部过滤器</strong>(GatewayFilter)</p><p>Gateway按照作用时间可以分为:<strong>PRE类型过滤器</strong> 和 <strong>POST类型过滤器</strong></p></blockquote><h4 id="5-3-1-PRE过滤器"><a href="#5-3-1-PRE过滤器" class="headerlink" title="5.3.1 PRE过滤器"></a>5.3.1 PRE过滤器</h4><blockquote><p>这种过滤器在请求被转发到微服务之前可以对请求进行拦截和修改，例如参数校验、验证码校验、权限校验、流量监控、日志输出以及协议转换等操作。</p></blockquote><h4 id="5-3-2-POST过滤器"><a href="#5-3-2-POST过滤器" class="headerlink" title="5.3.2 POST过滤器"></a>5.3.2 POST过滤器</h4><blockquote><p>这种过滤器在微服务对请求做出响应后可以对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等。</p></blockquote><h4 id="5-3-3-局部过滤器-GatewayFilter"><a href="#5-3-3-局部过滤器-GatewayFilter" class="headerlink" title="5.3.3 局部过滤器(GatewayFilter)"></a>5.3.3 局部过滤器(GatewayFilter)</h4><blockquote><p>GatewayFilter 是 Spring Cloud Gateway 网关中提供的一种应用在单个或一组路由上的过滤器。它可以对单个路由或者一组路由上传入的请求和传出响应进行拦截，并实现一些与业务无关的功能，比如登陆状态校验、签名校验、权限校验、日志输出、流量监控等。</p><p>Gateway内置局部过滤器如下：</p></blockquote><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230511235326.png"></p><blockquote><p>GatewayFilter 在配置文件（例如 application.yml）中的写法与 Predicate 类似，格式如下:</p></blockquote><pre><code class="yaml">spring:  cloud:    gateway:       routes:        - id: xxxx          uri: xxxx          predicates:            - Path=xxxx          filters:            - AddRequestParameter=X-Request-Id,1024 #过滤器工厂会在匹配的请求头加上一对请求头，名称为 X-Request-Id 值为 1024            - PrefixPath=/dept #在请求路径前面加上 /dept            ……</code></pre><h4 id="5-3-4-全局过滤器-GlobalFilter"><a href="#5-3-4-全局过滤器-GlobalFilter" class="headerlink" title="5.3.4 全局过滤器(GlobalFilter)"></a>5.3.4 全局过滤器(GlobalFilter)</h4><blockquote><p>GlobalFilter 是一种作用于所有的路由上的全局过滤器，通过它，我们可以实现一些统一化的业务功能，例如权限认证、IP 访问限制等。当某个请求被路由匹配时，那么所有的 GlobalFilter 会和该路由自身配置的 GatewayFilter 组合成一个过滤器链。</p><p>Spring Cloud Gateway 为我们提供了多种默认的 GlobalFilter，例如与转发、路由、负载均衡等相关的全局过滤器。但在实际的项目开发中，通常我们都会自定义一些自己的 GlobalFilter 全局过滤器以满足我们自身的业务需求，而很少直接使用 Spring Cloud Config 提供这些默认的 GlobalFilter。</p></blockquote><h2 id="6-Gateway路由断言过滤器配置示例"><a href="#6-Gateway路由断言过滤器配置示例" class="headerlink" title="6 Gateway路由断言过滤器配置示例"></a>6 Gateway路由断言过滤器配置示例</h2><pre><code class="yaml">server:  port: 7000spring:  application:    name: @artifactId@  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848        service: $&#123;spring.application.name&#125;    gateway:      discovery:        locator:          enabled: true # 让gateway可以发现nacos中的微服务      # gateway 使用简略配置可以直接注释掉下面配置即可(这里先不使用)      routes: # 路由数组[路由 就是指定当请求满足什么条件的时候转到哪个微服务]        # 转发到商品微服务        - id: p_route # 当前路由的标识, 要求唯一          uri: lb://cloud-alibaba-product # 请求要转发到的地址 # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略#          uri: http://127.0.0.1:8081 # 请求要转发到的地址 # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略          order: 1 # 路由的优先级,数字越小级别越高          predicates: # 断言(就是路由转发要满足的条件)            - Path=/product-server/** # 当请求路径满足Path指定的规则时,才进行路由转发            # 自定义断言限制年龄只有在18到35岁之间的人能访问 http://127.0.0.1:7000/product-server/product/1?age=25&amp;log=true#            - Age=18,35          filters: # 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改            - StripPrefix=1 # 转发之前去掉1层路径            # 测试自定义局部过滤器(这里可以看到是consoleLog开启 http://127.0.0.1:7000/product-server/product/1?age=25&amp;log=true)#            - Log=true,false        # 转发到订单微服务        - id: o_route # 当前路由的标识, 要求唯一          uri: lb://cloud-alibaba-order # 请求要转发到的地址 # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略#          uri: http://127.0.0.1:8082 # 请求要转发到的地址 # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略          order: 1 # 路由的优先级,数字越小级别越高          predicates: # 断言(就是路由转发要满足的条件)            - Path=/order-server/** # 当请求路径满足Path指定的规则时,才进行路由转发            # 自定义断言限制年龄只有在18到35岁之间的人能访问#            - Age=18,35          filters: # 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改            - StripPrefix=1 # 转发之前去掉1层路径        # 转发到用户微服务        - id: u_route # 当前路由的标识, 要求唯一          uri: lb://cloud-alibaba-user # 请求要转发到的地址 # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略#          uri: http://127.0.0.1:8071 # 请求要转发到的地址 # lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略          order: 1 # 路由的优先级,数字越小级别越高          predicates: # 断言(就是路由转发要满足的条件)            - Path=/user-server/** # 当请求路径满足Path指定的规则时,才进行路由转发            # 自定义断言限制年龄只有在18到35岁之间的人能访问#            - Age=18,35          filters: # 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改            - StripPrefix=1 # 转发之前去掉1层路径(用于拦截原始请求的路径使用数字表示要截断的路径的数量)</code></pre><h2 id="7-Gateway全局异常处理"><a href="#7-Gateway全局异常处理" class="headerlink" title="7 Gateway全局异常处理"></a>7 Gateway全局异常处理</h2><blockquote><p>在之前的Springboot项目中我们都是使用@ControllerAdvide注解来实现全局异常捕获的，但是在网关中出现异常一般都是请求没有到达导致的异常，所以我们需要在网关也要定制一层全局异常捕获，我们可以实现<strong>ErrorWebExceptionHandler</strong>接口，并覆盖handle方法实现：</p></blockquote><pre><code class="java">@Slf4j@Order(-1)@RequiredArgsConstructorpublic class GlobalExceptionHandler implements ErrorWebExceptionHandler &#123;    private final ObjectMapper objectMapper;    @Override    public Mono&lt;Void&gt; handle(ServerWebExchange exchange, Throwable ex) &#123;        ServerHttpResponse response = exchange.getResponse();        if (response.isCommitted()) &#123;            return Mono.error(ex);        &#125;        // header set        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);        if (ex instanceof ResponseStatusException) &#123;            response.setStatusCode(((ResponseStatusException) ex).getStatus());        &#125;        return response.writeWith(Mono.fromSupplier(() -&gt; &#123;            DataBufferFactory bufferFactory = response.bufferFactory();            try &#123;                log.warn(&quot;Error Spring Cloud Gateway : &#123;&#125; &#123;&#125;&quot;, exchange.getRequest().getPath(), ex.getMessage());                return bufferFactory.wrap(objectMapper.writeValueAsBytes(R.failed(ex.getMessage())));            &#125;            catch (JsonProcessingException e) &#123;                log.error(&quot;Error writing response&quot;, ex);                return bufferFactory.wrap(new byte[0]);            &#125;        &#125;));    &#125;&#125;</code></pre><h2 id="8-友链"><a href="#8-友链" class="headerlink" title="8 友链"></a>8 友链</h2><blockquote><p><a href="https://mp.weixin.qq.com/s/y-QNbHy_MPcRT0uPy-uCTA">Spring Cloud Gateway夺命10连问</a></p><p><a href="http://c.biancheng.net/springcloud/gateway.html">Gateway：Spring Cloud API网关组件</a></p><p><a href="https://zhuanlan.zhihu.com/p/299068076">Spring Cloud Gateway VS Zuul 比较，怎么选择</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pig开源项目学习-package-info.java的作用</title>
      <link href="/liukai/2023/05/10/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-package-info-java%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/liukai/2023/05/10/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-package-info-java%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="package-info-java的作用"><a href="#package-info-java的作用" class="headerlink" title="package-info.java的作用"></a>package-info.java的作用</h1><blockquote><p>摘要:</p><p>本文主要介绍Java中一种特殊的.java后缀java文件package-info.java作用</p></blockquote><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><blockquote><p>作用:</p><ul><li><strong>为标注在包上的注解Annotation提供便利</strong> (我们可以统一处理该注解包下的所有类，比如初始化，检查等等)</li><li><strong>声明友好类和包常量</strong> </li><li><strong>提供包的整体注释说明</strong></li></ul><p>概括:</p><p>pacakge-info.java是一个Java文件，可以添加到任何的Java源码包中。pacakge-info.java的目标是提供一个包级的文档说明或者是包级的注释。</p></blockquote><blockquote><p>pacakge-info.java文件中，<strong>唯一要求包含的内容是包的声明语句</strong>，比如:</p></blockquote><pre><code class="java">/*** This is domain module, the core business logic is implemented here.**/package com.rickie.tracking.domain;</code></pre><h2 id="2-创建方式"><a href="#2-创建方式" class="headerlink" title="2 创建方式"></a>2 创建方式</h2><blockquote><p>IDEA中创建方式截图如下:</p></blockquote><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230510154945.png"></p><h2 id="3-友链"><a href="#3-友链" class="headerlink" title="3 友链"></a>3 友链</h2><blockquote><p>详情参考:</p><p><a href="https://cloud.tencent.com/developer/beta/article/1874790">https://cloud.tencent.com/developer/beta/article/1874790</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Pig开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特殊java文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pig开源项目学习-git-commit-id-maven-plugin插件</title>
      <link href="/liukai/2023/05/10/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-git-commit-id-maven-plugin%E6%8F%92%E4%BB%B6/"/>
      <url>/liukai/2023/05/10/Pig%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-git-commit-id-maven-plugin%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="git-commit-id-maven-plugin插件简介"><a href="#git-commit-id-maven-plugin插件简介" class="headerlink" title="git-commit-id-maven-plugin插件简介"></a>git-commit-id-maven-plugin插件简介</h1><blockquote><p>摘要</p><p>本篇文章主要介绍本人正在学习的一个分布式开源项目所设计的技术 <strong>git-commit-id-maven-plugin</strong>插件.</p><p>对于此插件我们实际中只需要知道它是什么怎么用即可,不作为重点记录对象.</p></blockquote><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><blockquote><p>This plugin makes basic repository information available through maven resources. This can be used to display<br>“what version is this?” or “who has deployed this and when, from which branch?” information at runtime, making<br>it easy to find things like “oh, that isn’t deployed yet, I’ll test it tomorrow” and making both testers and<br>developers life easier. See <a href="https://github.com/git-commit-id/git-commit-id-maven-plugin">https://github.com/git-commit-id/git-commit-id-maven-plugin</a></p><p>翻译过来其实意思很简单:就是帮助开发人员清楚的看到打包部署的一些基本信息,比如谁在什么时间部署的哪一个分支等等;</p><p>具体详细的信息我们其实可以参考其github地址:</p><p><a href="https://github.com/git-commit-id/git-commit-id-maven-plugin">https://github.com/git-commit-id/git-commit-id-maven-plugin</a></p></blockquote><h2 id="2-maven依赖"><a href="#2-maven依赖" class="headerlink" title="2 maven依赖"></a>2 maven依赖</h2><pre><code class="xml">&lt;!--打包jar 与git commit 关联插件--&gt;&lt;plugin&gt;    &lt;groupId&gt;io.github.git-commit-id&lt;/groupId&gt;    &lt;artifactId&gt;git-commit-id-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;$&#123;git.commit.plugin&#125;&lt;/version&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;id&gt;get-the-git-infos&lt;/id&gt;            &lt;goals&gt;                &lt;goal&gt;revision&lt;/goal&gt;            &lt;/goals&gt;            &lt;phase&gt;initialize&lt;/phase&gt;        &lt;/execution&gt;    &lt;/executions&gt;    &lt;configuration&gt;        &lt;failOnNoGitDirectory&gt;false&lt;/failOnNoGitDirectory&gt;        &lt;generateGitPropertiesFile&gt;true&lt;/generateGitPropertiesFile&gt;        &lt;!--因为项目定制了jackson的日期时间序列化/反序列化格式，                因此这里要进行配置,不然通过management.info.git.mode=full进行完整git信息监控时会存在问题             --&gt;        &lt;dateFormat&gt;yyyy-MM-dd HH:mm:ss&lt;/dateFormat&gt;        &lt;includeOnlyProperties&gt;            &lt;includeOnlyProperty&gt;^git.build.(time|version)$&lt;/includeOnlyProperty&gt;            &lt;includeOnlyProperty&gt;^git.commit.(id|message|time).*$&lt;/includeOnlyProperty&gt;        &lt;/includeOnlyProperties&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre><h2 id="3-使用实例"><a href="#3-使用实例" class="headerlink" title="3 使用实例"></a>3 使用实例</h2><blockquote><p>使用示例其实可以参考<a href="https://gitee.com/log4j/pig">Pig开源</a>项目的使用也可以百度搜索相关内容,或者到管网查看使用教程</p><p>类似文章连接:</p><p><a href="https://blog.csdn.net/u010979642/article/details/107810883">https://blog.csdn.net/u010979642/article/details/107810883</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Pig开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>订单超时解决方案-RocketMQ延迟消息</title>
      <link href="/liukai/2023/04/21/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-RocketMQ%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/"/>
      <url>/liukai/2023/04/21/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-RocketMQ%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="订单超时解决方案RocketMQ延时消息"><a href="#订单超时解决方案RocketMQ延时消息" class="headerlink" title="订单超时解决方案RocketMQ延时消息"></a>订单超时解决方案RocketMQ延时消息</h1><blockquote><p>摘要:</p><p>本文主要介绍RocketMQ延时消息解决订单超时问题</p></blockquote><h2 id="1-RocketMQ简介"><a href="#1-RocketMQ简介" class="headerlink" title="1 RocketMQ简介"></a>1 RocketMQ简介</h2><blockquote><p>可以参考阿里云社区的这篇文章,写的很详细,并带有实际举例说明:</p><p><a href="https://developer.aliyun.com/article/780968">https://developer.aliyun.com/article/780968</a></p></blockquote><h2 id="2-延时消息解决订单超时问题"><a href="#2-延时消息解决订单超时问题" class="headerlink" title="2 延时消息解决订单超时问题"></a>2 延时消息解决订单超时问题</h2><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>订单超时解决方案-RabbitMQ死信队列</title>
      <link href="/liukai/2023/04/20/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-RabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
      <url>/liukai/2023/04/20/%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-RabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ死信队列解决订单超时"><a href="#RabbitMQ死信队列解决订单超时" class="headerlink" title="RabbitMQ死信队列解决订单超时"></a>RabbitMQ死信队列解决订单超时</h1><blockquote><p>摘要:</p><p>本文主要介绍利用分布式组件RabbitMQ解决订单超时的问题</p></blockquote><h2 id="1-死信以及TTL概念"><a href="#1-死信以及TTL概念" class="headerlink" title="1  死信以及TTL概念"></a>1  死信以及TTL概念</h2><blockquote><p>死信，在官网中对应的单词为“Dead Letter”;</p><p>它是RabbitMQ中的一种消息机制</p><p>TTL：即消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL，如果对队列设置，则队列中所有的消息都具有相同的过期时间。超过了这个时间，我们认为这个消息就死了，称之为死信。</p></blockquote><h3 id="1-1-队列中消息出现死信的几种情况"><a href="#1-1-队列中消息出现死信的几种情况" class="headerlink" title="1.1 队列中消息出现死信的几种情况"></a>1.1 队列中消息出现死信的几种情况</h3><blockquote><ol><li>消息被否定确认,其实就是呗消费者拒绝.使用 <code>channel.basicNack</code> 或 <code>channel.basicReject</code> ，并且此时<code>requeue</code> 属性被设置为<code>false</code>;</li><li>消息在队列中存活的时间超过设置的TTL时间;</li><li>消息在队列的消息数量已经超过了最大的队列长度;(队列可以设置最大消息数量的属性,如果超出了这个范围那么多出来的就是死信).</li></ol></blockquote><h3 id="1-2-如何配置死信队列"><a href="#1-2-如何配置死信队列" class="headerlink" title="1.2  如何配置死信队列"></a>1.2  如何配置死信队列</h3><blockquote><p>上面说到三种消息成为死信的情况,那么我们成为死信的消息将”何去何从”呢?</p><p>其实我们一样可以创建一个专门接收死信的队列来存放管理这些消息—死信队列</p><p>死信队列其实就是一个普通的队列;所以配置过程如下:</p><ol><li>配置业务队列,配置业务交换机,并将业务队列绑定到交换机上;</li><li>配置业务队列的时候为业务队列设置属性,(TTL过期时间,死信交换机名称,可死信队列路由key)</li><li>配置死信队列,配置死信交换机(就是一个普通的交换机),为死信队列绑定死信交换机;</li></ol></blockquote><h3 id="1-3-队列属性"><a href="#1-3-队列属性" class="headerlink" title="1.3 队列属性"></a>1.3 队列属性</h3><blockquote><p>上面说到为业务队列设置属性,以便队列中的消息变成死信之后通过死信交换机路由到死信队列,下面就是我们要配置的属性</p><ol><li>x-dead-letter-exchange 此属性设置死信交换机名称</li><li>x-dead-letter-routing-key 此属性设置死信队列的routing key</li><li>x-message-ttl 此属性设置队列中消息过期时间单位ms</li><li>x-max-length 此属性设置队列的最大消息数量,超过这个值的消息将会变成死信</li></ol><p>注意:</p><p>​x-message-ttl属性设置的是队列中所有消息的过期时间,我们也可以在发送消息的时候单独设置每一个消息的过期时间;</p><p>​如果消息队列和消息都设置了过期时间,那么哪一个设置的时间小就按照哪一个.</p></blockquote><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h2><blockquote><p>理论的东西整理结束了下面就可以直接上代码和演示截图了</p><p>下面是主要代码</p></blockquote><h3 id="2-1-配置死信队列死信交换机"><a href="#2-1-配置死信队列死信交换机" class="headerlink" title="2.1 配置死信队列死信交换机"></a>2.1 配置死信队列死信交换机</h3><pre><code class="java">/** * 死信队列交换机配置 * * @author liukai * @since 2023/4/19 13:24 */@Configurationpublic class DieExchangeQueueConfig &#123;    /**     * 业务队列A     *     * @return &#123;@link Queue &#125;     */    @Bean    public Queue busQueueA() &#123;        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();        // 队列过期时间TTL,单位毫秒        args.put(&quot;x-message-ttl&quot;, 5000);        // x-dead-letter-exchange    这里声明当前队列绑定的死信交换机        args.put(&quot;x-dead-letter-exchange&quot;, RabbitMqConstant.DIE_AB_TOPIC_EXCHANGE_NAME);        // x-dead-letter-routing-key  这里声明当前队列的死信路由key        args.put(&quot;x-dead-letter-routing-key&quot;, RabbitRoutingKeyEnum.DIE_QUEUE_A_ROUTING_KEY.getValue());        return new Queue(RabbitMqConstant.BUS_QUEUE_A_NAME, true, false, false, args);    &#125;    /**     * 业务队列AB的交换机     *     * @return &#123;@link TopicExchange &#125;     */    @Bean    public TopicExchange busAbTopicExchange() &#123;        return new TopicExchange(RabbitMqConstant.BUS_AB_TOPIC_EXCHANGE_NAME);    &#125;    /**     * 业务队列A绑定到业务AB交换机     *     * @return &#123;@link Binding &#125;     */    @Bean    public Binding bindBusTopicExchangeA() &#123;        return BindingBuilder                // 绑定队列                .bind(busQueueA())                // 到交换机                .to(busAbTopicExchange())                .with(RabbitRoutingKeyEnum.BUS_QUEUE_A_ROUTING_KEY.getValue());    &#125;    /**     * 死信队列A     *     * @return &#123;@link Queue &#125;     */    @Bean    public Queue dieQueueA() &#123;        return new Queue(RabbitMqConstant.DIE_QUEUE_A_NAME);    &#125;    /**     * 死信交换机     *     * @return &#123;@link TopicExchange &#125;     */    @Bean    public TopicExchange dieAbTopicExchange() &#123;        return new TopicExchange(RabbitMqConstant.DIE_AB_TOPIC_EXCHANGE_NAME);    &#125;    /**     * 死信队列A绑定死信交换机     *     * @return &#123;@link Binding &#125;     */    @Bean    public Binding bindDieTopicExchangeA() &#123;        return BindingBuilder                // 绑定队列                .bind(dieQueueA())                // 到交换机                .to(dieAbTopicExchange())                .with(RabbitRoutingKeyEnum.DIE_QUEUE_A_ROUTING_KEY.getValue());    &#125;&#125;</code></pre><h3 id="2-2-消费方监听"><a href="#2-2-消费方监听" class="headerlink" title="2.2 消费方监听"></a>2.2 消费方监听</h3><pre><code class="java">/** * 死信队列消息监听消费者 * * @author liukai * @since 2023/4/19 17:11 */@Componentpublic class DieRabbitListener &#123;    @RabbitListener(queues = RabbitMqConstant.DIE_QUEUE_A_NAME)    public void dieA(Map&lt;String, Object&gt; map) &#123;        System.out.println(&quot;消费者接收到死信队列A中的消息:&quot; + map.toString());        // 根据 订单ID查询DB更新订单状态,设置订单过期.增加库存...        //coding... 这里后面单独列出一期订单秒杀业务博文再详细复述.    &#125;&#125;</code></pre><h3 id="2-3-模拟生产方"><a href="#2-3-模拟生产方" class="headerlink" title="2.3 模拟生产方"></a>2.3 模拟生产方</h3><pre><code class="java">@RestController@RequiredArgsConstructor@RequestMapping(&quot;/rabbitmq/test&quot;)public class RabbitMqTestController &#123;    private final RabbitMqTestService rabbitMqTestService;        @GetMapping(&quot;/send/message/topic/die/queue/a&quot;)    public Map&lt;String, Object&gt; sendMessageTopicDieQueueA(String message) &#123;        return rabbitMqTestService.sendMessageTopicDieQueueA(message);    &#125;&#125;</code></pre><pre><code class="java">@Service@RequiredArgsConstructorpublic class RabbitMqTestServiceImpl implements RabbitMqTestService &#123;    private final RabbitTemplate rabbitTemplate;        @Override    public Map&lt;String, Object&gt; sendMessageTopicDieQueueA(String message) &#123;        Map&lt;String, Object&gt; messageMap = getMessageMap(message);        rabbitTemplate.convertAndSend(RabbitMqConstant.BUS_AB_TOPIC_EXCHANGE_NAME, RabbitRoutingKeyEnum.BUS_QUEUE_A_ROUTING_KEY.getValue(), messageMap);        return messageMap;    &#125;&#125;</code></pre><blockquote><p>注意:</p><p>注意这种方式是正常发送消息到业务队列,我们在上面已经配置了业务队列的ttl(args.put(“x-message-ttl”, 5000);)所以这里面的消息如果超过可这个时间没有被消费者消费就会进入死信队列,我们消费方就会监听到死信队列中的消息,</p><p>此外我们还可以单独对消息设置ttl这样如果该消息的ttl如果比对列的小就会按照消息的ttl走</p><p>对消息单独设置TTL的代码如下:</p></blockquote><pre><code class="java">@Override    public Map&lt;String, Object&gt; sendMessageTopicDieQueueAttlmes(String message) &#123;        Map&lt;String, Object&gt; messageMap = getMessageMap(message);        //给消息设置过期时间        MessagePostProcessor messagePostProcessor = new MessagePostProcessor() &#123;            @Override            public Message postProcessMessage(Message message) throws AmqpException &#123;                // 这里单位也是毫秒，但这里是字符串的形式                message.getMessageProperties().setExpiration(&quot;3000&quot;);                //还可以为消息设置编码                message.getMessageProperties().setContentEncoding(&quot;UTF-8&quot;);                return message;            &#125;        &#125;;        rabbitTemplate.convertAndSend(RabbitMqConstant.BUS_AB_TOPIC_EXCHANGE_NAME, RabbitRoutingKeyEnum.BUS_QUEUE_A_ROUTING_KEY.getValue(), messageMap, messagePostProcessor);        return messageMap;    &#125;</code></pre><h2 id="3-运行截图"><a href="#3-运行截图" class="headerlink" title="3 运行截图"></a>3 运行截图</h2><blockquote><p>有消费者消费情况下 不会进入死信队列中</p></blockquote><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230421100458.png"><br><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230421100525.png"></p><blockquote><p>注释掉业务队列的监听三秒之后进入死信队列</p></blockquote><p><img src="https://gitee.com/mrkay0313/images/raw/master/img/20230421100703.png"></p><blockquote><p>不对消息单独设置TTL的设置就不再演示 上面已经可以看出当单独对消息设置TTL之后如果TTL比队列的TTL小就会按照消息的走3秒时效</p><p>如果不单独设置就会按照队列的TTL走5秒时效</p></blockquote><h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4 结束语"></a>4 结束语</h2><blockquote><p>参考链接:</p><p><a href="https://cloud.tencent.com/developer/article/1463065">【RabbitMQ】一文带你搞定RabbitMQ死信队列 - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://blog.csdn.net/doupengzp/article/details/106929216">RabbitMQ的死信队列详解及实现_窦朋飞的博客-CSDN博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch和线程池的简单使用</title>
      <link href="/liukai/2023/04/18/CountDownLatch%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/liukai/2023/04/18/CountDownLatch%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一次CountDownLatch和ScheduledExecutorService线程池使用"><a href="#记录一次CountDownLatch和ScheduledExecutorService线程池使用" class="headerlink" title="记录一次CountDownLatch和ScheduledExecutorService线程池使用"></a>记录一次CountDownLatch和ScheduledExecutorService线程池使用</h1><blockquote><p>摘要:</p><p>本文主要记录使用ScheduledExecutorService任务调度线程池配合CountDownLatch 计数器实现一次大文件处理的业务.</p></blockquote><h2 id="1-ScheduledExecutorService-介绍"><a href="#1-ScheduledExecutorService-介绍" class="headerlink" title="1 ScheduledExecutorService 介绍"></a>1 ScheduledExecutorService 介绍</h2><blockquote><p>ScheduledExecutorService是基于ExecutorService的功能实现的延迟和周期执行任务的功能。每个任务以及每个任务的每个周期都会提交到线程池中由线程去执行，所以任务在不同周期内执行它的线程可能是不同的。ScheduledExecutorService接口的默认实现类是ScheduledThreadPoolExecutor。在周期执行的任务中，如果任务执行时间大于周期时间，则会以任务时间优先，等任务执行完毕后才会进入下一次周期</p><p>参考链接: <a href="https://blog.csdn.net/liuyu973971883/article/details/108059865">https://blog.csdn.net/liuyu973971883/article/details/108059865</a></p></blockquote><h2 id="2-CountDownLatch-介绍"><a href="#2-CountDownLatch-介绍" class="headerlink" title="2 CountDownLatch 介绍"></a>2 CountDownLatch 介绍</h2><blockquote><p>CountDownLatch是一个同步工具类，用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）。</p><p>CountDownLatch能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务。</p></blockquote><h3 id="2-1-典型用法"><a href="#2-1-典型用法" class="headerlink" title="2.1 典型用法"></a>2.1 典型用法</h3><blockquote><p>CountDownLatch典型用法：1、某一线程在开始运行前等待n个线程执行完毕。将CountDownLatch的计数器初始化为new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownLatch.countDown()，当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p></blockquote><blockquote><p>CountDownLatch典型用法：2、实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的CountDownLatch(1)，将其计算器初始化为1，多个线程在开始执行任务前首先countdownlatch.await()，当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒。</p></blockquote><blockquote><p>资料参考链接: <a href="https://www.cnblogs.com/Lee_xy_z/p/10470181.html">https://www.cnblogs.com/Lee_xy_z/p/10470181.html</a></p></blockquote><h2 id="3-具体到业务"><a href="#3-具体到业务" class="headerlink" title="3 具体到业务"></a>3 具体到业务</h2><blockquote><p>本次使用任务调度线程池和线程计数器的背景是项目中需要解析一个超大json文件,</p><p>文件中有超过10W个不规则图形组成的大的地图模型json(模型提供的地图map文件,单文件大小近80M,不规则图形的每一个点对应一个经纬度),我的任务就是判断DB表里的一些点,哪些在此大的地图map中(json图形中,不是点对点是点在地图范围内)</p><p>解决此类问题单线程解决肯定不可行,所以就使用了多线程,当时需要拆分大的json文件,经过查阅资料了解到任务调度线程池更契合本次业务需求,最终选择使用CountDownLatch 线程计数器配合ScheduledExecutorService完成业务</p></blockquote><h3 id="3-1-简单罗列主要业务代码"><a href="#3-1-简单罗列主要业务代码" class="headerlink" title="3.1 简单罗列主要业务代码"></a>3.1 简单罗列主要业务代码</h3><pre><code class="java">public class PreviewModelServiceImpl implements PreviewModelService &#123;     @Override    public Integer callBack(HttpServletRequest request) &#123;        JSONObject jsonObject = ModelGetBodyParamsUtil.getBodyParamToJsonObj(request);        if (jsonObject != null) &#123;            String taskId = jsonObject.getStr(&quot;taskId&quot;);            String status = jsonObject.getStr(&quot;status&quot;);            //阻塞线程执行 保证多线程执行期间不会有其他线程进入            synchronized (this) &#123;                if (ModelDealEnum.DEAL_STATUS_SUCCESS.getValue().equals(status)) &#123;                    //根据idx查找是已经推送获取过结果                    List&lt;ModelAnalyzeResultIdx&gt; pushedList = modelAnalyzeResultIdxMapper.selectPushedDatasByIdx(taskId);                    if (CollUtil.isNotEmpty(pushedList)) &#123;                        //解析数据并入库                        ModelAnalyzeResultIdx source = pushedList.get(0);                        try &#123;                            //获取floodRisk积水风险统计geoJson(多线程进行处理GeoJson)                            List&lt;WaterPoint&gt; waterPoints = analyzeService.analyzeGeoJsonDatas(source);                        &#125; catch (Exception e) &#123;                            log.error(&quot;模型解析错误&quot;, e);                        &#125;                    &#125;                &#125;            &#125;        &#125;        return 0;    &#125;&#125;</code></pre><pre><code class="java">package com.keepsoft.devbase.service.impl;import cn.hutool.core.collection.CollUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.crypto.digest.MD5;import cn.hutool.http.HttpResponse;import cn.hutool.http.HttpUtil;import cn.hutool.json.JSONArray;import cn.hutool.json.JSONObject;import cn.hutool.json.JSONUtil;import com.baomidou.dynamic.datasource.annotation.DS;import com.keepsoft.devbase.entity.ModelAnalyzeResultIdx;import com.keepsoft.devbase.entity.ModelDataPng;import com.keepsoft.devbase.entity.ModelFileResultIdx;import com.keepsoft.devbase.entity.WaterPoint;import com.keepsoft.devbase.enums.ModelDealEnum;import com.keepsoft.devbase.mapper.ModelAnalyzeResultIdxMapper;import com.keepsoft.devbase.mapper.ModelDataPngMapper;import com.keepsoft.devbase.mapper.ModelFileResultIdxMapper;import com.keepsoft.devbase.mapper.WaterPointMapper;import com.keepsoft.devbase.service.AnalyzeService;import com.keepsoft.devbase.task.ModelGeoJsonDealTask;import com.keepsoft.devbase.utils.ConfigUtils;import com.keepsoft.devbase.utils.GeoJsonUtil;import com.keepsoft.devbase.utils.ZipFileUtils;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.concurrent.BasicThreadFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.*;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledThreadPoolExecutor;/** * @author liukai * @date 2022/11/24 10:05 */@SuppressWarnings(&quot;all&quot;)@Slf4j@Servicepublic class AnalyzeServiceImpl implements AnalyzeService &#123;    /**     * 创建线程池     */    private static final ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(12, new BasicThreadFactory.Builder().namingPattern(&quot;model-geojson-analyze-pool-%d&quot;).daemon(true).build());    @Override    @DS(value = &quot;hsyb&quot;)    public List&lt;WaterPoint&gt; analyzeGeoJsonDatas(ModelAnalyzeResultIdx source) throws Exception &#123;        //coding ...        //需要多线程处理        if (GeoJsonUtil.needMultiThreadDeal(allReseaus)) &#123;            List&lt;List&lt;List&lt;JSONArray&gt;&gt;&gt; splitContainer = GeoJsonUtil.split(allReseaus, 20000);            //计数器:所有子线程开始处理数据集等待计数结束之后主线程开始执行            List&lt;WaterPoint&gt; waterPoints = waterPointMapper.selectList(null);            CountDownLatch latch = new CountDownLatch(splitContainer.size());            List&lt;ModelGeoJsonDealTask&gt; taskList = new ArrayList&lt;ModelGeoJsonDealTask&gt;(splitContainer.size());            for (int i = 0; i &lt; splitContainer.size(); i++) &#123;                ModelGeoJsonDealTask task_i = new ModelGeoJsonDealTask(true, latch, splitContainer.get(i), waterPoints);                taskList.add(task_i);                //执行                executorService.submit(task_i);            &#125;            //阻塞主线程            latch.await();            //主线程开始处理            //coding ...            &#125;    &#125;&#125;</code></pre><pre><code class="java">/** * GeoJson处理线程 * * @author liukai * @date 2022/12/1 9:25 */@Slf4j@Datapublic class ModelGeoJsonDealTask implements Runnable &#123;    /**     * 成功标识     */    private boolean success = true;    /**     * 线程计数器     */    private CountDownLatch countDownLatch;    /**     * 待处理数据集     */    private List&lt;List&lt;JSONArray&gt;&gt; toDealList;    /**     * 内涝点     */    private List&lt;WaterPoint&gt; waterPoints;    /**     * 线程得到的在网格内的内涝点     */    private List&lt;WaterPoint&gt; inReseauWaterPoints = new ArrayList&lt;WaterPoint&gt;();    /**     * 最终结果容器     */    private List&lt;List&lt;String&gt;&gt; resultList = new ArrayList&lt;List&lt;String&gt;&gt;();    public ModelGeoJsonDealTask(boolean success, CountDownLatch countDownLatch, List&lt;List&lt;JSONArray&gt;&gt; toDealList, List&lt;WaterPoint&gt; waterPoints) &#123;        this.success = success;        this.countDownLatch = countDownLatch;        this.toDealList = toDealList;        this.waterPoints = waterPoints;    &#125;    @Override    public void run() &#123;        try &#123;            long stms = System.currentTimeMillis();            log.info(&quot;======处理geojson线程：【&#123;&#125;】开始执行解析，当前时间(毫秒值)：【&#123;&#125;】&quot;, Thread.currentThread().getName(), stms);            //拼网格            GeoJsonUtil.spliceReseausAndDecidePointInReseau(toDealList, resultList, waterPoints, inReseauWaterPoints);            long endms = System.currentTimeMillis();            long during = (endms - stms) / 1000;            log.info(&quot;======处理geojson线程：【&#123;&#125;】解析执行结束，当前时间(毫秒值)：【&#123;&#125;ms】，用时：【&#123;&#125;s】&quot;, Thread.currentThread().getName(), endms, during);        &#125; catch (Exception e) &#123;            log.error(&quot;处理geojson线程:【&#123;&#125;】,处理geojson发生异常:&quot;, Thread.currentThread().getName(), e);            //失败            success = false;        &#125; finally &#123;            //计数器减1            countDownLatch.countDown();        &#125;    &#125;&#125;</code></pre><h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4 结束语"></a>4 结束语</h2><blockquote><p>本文只是见到那记录 ScheduledExecutorService 和 CountDownLatch 的使用具体详细概念并没有做详细学习,后期会多线程篇章里深入学习记录.</p></blockquote><h2 id="5-参考链接"><a href="#5-参考链接" class="headerlink" title="5 参考链接"></a>5 参考链接</h2><blockquote><p> <a href="https://blog.csdn.net/liuyu973971883/article/details/108059865">https://blog.csdn.net/liuyu973971883/article/details/108059865</a></p><p><a href="https://www.cnblogs.com/Lee_xy_z/p/10470181.html">https://www.cnblogs.com/Lee_xy_z/p/10470181.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CountDownLatch </tag>
            
            <tag> ScheduledExecutorService </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis发布订阅和Redis监听</title>
      <link href="/liukai/2023/04/15/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%92%8CRedis%E7%9B%91%E5%90%AC/"/>
      <url>/liukai/2023/04/15/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%92%8CRedis%E7%9B%91%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis发布订阅和监听"><a href="#Redis发布订阅和监听" class="headerlink" title="Redis发布订阅和监听"></a>Redis发布订阅和监听</h1><blockquote><p>摘要”</p><p>本篇博客主要介绍以下内容:</p><ul><li>Redis发布订阅;</li><li>Redis监听过期</li></ul></blockquote><h2 id="1-Redis发布订阅"><a href="#1-Redis发布订阅" class="headerlink" title="1 Redis发布订阅"></a>1 Redis发布订阅</h2><blockquote><p>注意:</p><p>Redis版本大于等2.0</p></blockquote><h3 id="1-1-Redis发布订阅代码"><a href="#1-1-Redis发布订阅代码" class="headerlink" title="1.1 Redis发布订阅代码"></a>1.1 Redis发布订阅代码</h3><pre><code class="java">/** * Redis配置 * * @author liukai * @since 2023/3/22 15:30 */@Configurationpublic class RedisConfig &#123;    @Value(&quot;$&#123;redis.topic&#125;&quot;)    private String redisTopic;    @Bean    public RedisMessageListenerContainer listenerContainer(RedisConnectionFactory factory, MessageListenerAdapter messageListenerAdapter) &#123;        RedisMessageListenerContainer container = new RedisMessageListenerContainer();        container.setConnectionFactory(factory);        List&lt;Topic&gt; topicList = Arrays.asList(new PatternTopic(redisTopic));        container.addMessageListener(messageListenerAdapter, topicList);        return container;    &#125;    @Bean    public MessageListenerAdapter messageListenerAdapter(RedisReceiver redisReceiver) &#123;        return new MessageListenerAdapter(redisReceiver, &quot;onMessage&quot;);    &#125;&#125;</code></pre><pre><code class="java">/** * redis 消息监听回调 * * @author liukai * @since 2023/3/22 15:42 */@Component@Slf4jpublic class RedisReceiver implements MessageListener &#123;    /**     * description     *     * @param message 信息     * @param bytes   字节数组     */    @Override    public void onMessage(@Nullable Message message, @Nullable byte[] bytes) &#123;        log.info(&quot;进来了回调方法！&quot;);        log.info(&quot;回调的信息 message=&#123;&#125;&quot;, message);        log.info(&quot;回调的信息 bytes=&#123;&#125;&quot;, StrUtil.str(bytes, CharsetUtil.UTF_8));    &#125;&#125;</code></pre><h3 id="1-2-Redis发布订阅结果演示"><a href="#1-2-Redis发布订阅结果演示" class="headerlink" title="1.2 Redis发布订阅结果演示"></a>1.2 Redis发布订阅结果演示</h3><blockquote><p>首先创建一个controller来完成模拟发布方</p></blockquote><pre><code class="java">/** * 测试控制层 * * @author liukai * @since 2023/3/22 0:05 */@RestController@Api(tags = &quot;测试接口层&quot;)@RequestMapping(&quot;/test/apis&quot;)@RequiredArgsConstructorpublic class TestController &#123;    private final ISysUserService iSysUserService;    private final IStWyzService iStWyzService;    private final StringRedisTemplate stringRedisTemplate;    @Value(&quot;$&#123;redis.topic&#125;&quot;)    private String redisTopic;    @GetMapping(&quot;/redis/message/push&quot;)    @Operation(summary = &quot;Redis发布消息&quot;)    public void wyzList() &#123;        SysUser user = iSysUserService.getUser(&quot;zs&quot;);        stringRedisTemplate.convertAndSend(redisTopic, JSONUtil.toJsonStr(user));    &#125;</code></pre><blockquote><p>发送后控制台打印结果截图如下</p></blockquote><p><img src="http://gitee.com/mrkay0313/images/raw/master/img/20230415233536.png"></p><p><img src="http://gitee.com/mrkay0313/images/raw/master/img/20230415233608.png"></p><p><img src="http://gitee.com/mrkay0313/images/raw/master/img/20230415233637.png"></p><h2 id="2-Redis监听过期Key"><a href="#2-Redis监听过期Key" class="headerlink" title="2 Redis监听过期Key"></a>2 Redis监听过期Key</h2><blockquote><p>Redis监听过期Key需要对Redis配置文件 reids.windows.config 文件进行修改</p><p>这里演示使用windows版Redis的修改,Linux修改的参数一致</p></blockquote><h3 id="2-1-修改Redis配置并重启"><a href="#2-1-修改Redis配置并重启" class="headerlink" title="2.1 修改Redis配置并重启"></a>2.1 修改Redis配置并重启</h3><p><img src="http://gitee.com/mrkay0313/images/raw/master/img/20230415234716.png"></p><blockquote><p>启动重启redis服务</p><p>redis-server redis.windows.config</p></blockquote><h3 id="2-2-代码中增加过期监听topic"><a href="#2-2-代码中增加过期监听topic" class="headerlink" title="2.2 代码中增加过期监听topic"></a>2.2 代码中增加过期监听topic</h3><blockquote><p>增加代码如下</p></blockquote><pre><code class="java">/** * Redis配置 * * @author liukai * @since 2023/3/22 15:30 */@Configurationpublic class RedisConfig &#123;    @Value(&quot;$&#123;redis.topic&#125;&quot;)    private String redisTopic;    @Bean    public RedisMessageListenerContainer listenerContainer(RedisConnectionFactory factory, MessageListenerAdapter messageListenerAdapter) &#123;        RedisMessageListenerContainer container = new RedisMessageListenerContainer();        container.setConnectionFactory(factory);        List&lt;Topic&gt; topicList = Arrays.asList(new PatternTopic(&quot;__keyevent@0__:expired&quot;), new PatternTopic(redisTopic));        container.addMessageListener(messageListenerAdapter, topicList);        return container;    &#125;    @Bean    public MessageListenerAdapter messageListenerAdapter(RedisReceiver redisReceiver) &#123;        return new MessageListenerAdapter(redisReceiver, &quot;onMessage&quot;);    &#125;&#125;</code></pre><h3 id="2-3-Redis监听过期Key结果演示"><a href="#2-3-Redis监听过期Key结果演示" class="headerlink" title="2.3 Redis监听过期Key结果演示"></a>2.3 Redis监听过期Key结果演示</h3><blockquote><p>controller增加一个接口</p></blockquote><pre><code class="java">/** * 测试控制层 * * @author liukai * @since 2023/3/22 0:05 */@RestController@Api(tags = &quot;测试接口层&quot;)@RequestMapping(&quot;/test/apis&quot;)@RequiredArgsConstructorpublic class TestController &#123;    private final ISysUserService iSysUserService;    private final IStWyzService iStWyzService;    private final StringRedisTemplate stringRedisTemplate;    @Value(&quot;$&#123;redis.topic&#125;&quot;)    private String redisTopic;    @GetMapping(&quot;/redis/message/push&quot;)    @Operation(summary = &quot;Redis发布消息&quot;)    public void wyzList() &#123;        SysUser user = iSysUserService.getUser(&quot;zs&quot;);        stringRedisTemplate.convertAndSend(redisTopic, JSONUtil.toJsonStr(user));    &#125;    @GetMapping(&quot;/redis/message/listener/exp&quot;)    @Operation(summary = &quot;redis监听过期key&quot;)    public void redisMessageListenerExp() &#123;        SysUser user = iSysUserService.getUser(&quot;zs&quot;);        //60秒过期        stringRedisTemplate.opsForValue().set(&quot;exp_key_&quot; + RandomUtil.randomNumbers(5), user.getUserName(), 60, TimeUnit.SECONDS);    &#125;&#125;</code></pre><blockquote><p>控制太答应结果如下</p></blockquote><p><img src="http://gitee.com/mrkay0313/images/raw/master/img/20230415235651.png"></p><p><img src="http://gitee.com/mrkay0313/images/raw/master/img/20230415235738.png"></p><p><img src="http://gitee.com/mrkay0313/images/raw/master/img/20230415235816.png"></p><h2 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3 结束语"></a>3 结束语</h2><blockquote><p>本次主要记录了Redis的发布订阅和过期监听并没有Redis进行深入研究.</p><p>好了文章记录结束</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/liukai/2023/04/10/hello-world/"/>
      <url>/liukai/2023/04/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
